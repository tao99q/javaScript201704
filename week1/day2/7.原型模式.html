<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>原型模式</title>
</head>
<body>
<!--
原型模式：
  1.每一个函数数据类型（函数，所有的类）天生都有一个prototype（原型）属性
  prototype；里面存储的是共有的属性和方法，这个属性是一个对象数据类型的，浏览器就会给他 开辟一个堆内存，开辟的这个堆内存中也有一个天生自带的属性constructor，而且指向的的是类本身
  2.所有的对象数据类型（除了函数和基本数据类型其他的都是，实例是对象数据类型，prototype是对象数据类型）天生自带一个属性叫__proto__,指向所属类的原型



  所有的类都是函数数据类型，Object是一个类，说明Object是函数数据类型的。他就是函数Function类的一个实例


-->
<script type="text/javascript">
    function FF() {
        //this
        this.a=12;
        this.ff=function () {
            console.log(this.a);
        }
    }
    FF.prototype.getA=function () {
        console.log("哈哈哈")
    };
    var f=new FF;
    var f1=new FF;
    //实例通过this得到的是私有属性和方法，还可以继承所属类的公有属性和方法，比如说，每个数组都可以用sort这个方法，这个方法是在类Array原型上，因为所有的数组都是Array类的一个具体的实例，所以只要是数组就可以用，
    console.log(FF.prototype.constructor);
    console.log(FF.prototype.__proto__);

    console.log(Array.prototype);
    var obj={a:1};
    console.log(obj.__proto__===Object.prototype);
    console.log(Object.prototype);

    //
    var obj={1:1};
    console.log( obj instanceof Object);
    console.log( Object instanceof Function);
    console.log( Function instanceof Object);


    var ary=[1,2,3];
    console.log(ary.__proto__===Array.prototype);
    console.log(Array.prototype.__proto__);
    console.log(Array instanceof  Function);
    console.dir(Function);


    Array.prototype.quChong=function () {
        //this 就是那个具体的数组实例
        for (var i=0;i<this.length;i++){
            if(this.indexOf(this[i])!==this.lastIndexOf(this[i])){
                this.splice(i,1);
                i--
            }
        }
        return this
    };
    Array.prototype.splice=function () {
        if(arguments.length=0){
            return this
        }
        return this
    };

    var ary=[1,2,3,1,1,2];
    console.log(ary.quChong().sort());
    //思考作业，模拟数组slice方法，在数组原型上增加方法
</script>
</body>
</html>